return {
	ActorEditor = nil,
	AreaEditor = nil,
	AssemblyEditor = nil,
	BaseEditor = nil,
	EditorActivity = nil,
	GameActivity = {
		CPUTeam = "Which team is CPU-managed, if any (-1). Legacy, now controlled by PlayerNIsHuman, where N is between 1 and 4 inclusive.",
		DeliveryDelay = "Time it takes for a delivery to be made in milliseconds.",
		DefaultFogOfWar = "Default fog of war value.",
		DefaultRequireClearPathToOrbit = "Default clear path to orbit value.",
		DefaultDeployUnits = "Default deploy units value.",
		DefaultGoldCake = "Default gold amount for Cake difficulty.",
		DefaultGoldEasy = "Default gold amount for Easy difficulty.",
		DefaultGoldMedium = "Default gold amount for Medium difficulty.",
		DefaultGoldHard = "Default gold amount for Hard difficulty.",
		DefaultGoldNuts = "Default gold amount for Nuts difficulty.",
		FogOfWarSwitchEnabled = "Whether the fog of war switch is enabled in the scenario setup dialog.",
		DeployUnitsSwitchEnabled = "Whether the deploy units switch is enabled in the scenario setup dialog.",
		GoldSwitchEnabled = "Whether the gold switch is enabled in the scenario setup dialog.",
		RequireClearPathToOrbitSwitchEnabled = "Whether the require clear path to orbit switch is enabled in the scenario setup dialog.",
		BuyMenuEnabled = "Whether the buy menu is enabled.",
	},
	GAScripted = {
		ScriptPath = "The path to a Lua script file to run.",
		LuaClassName = "The name of the class (table) defining the logic of this in Lua, as specified in the script file.",
	},
	GATutorial = nil,
	GibEditor = nil,
	MultiplayerGame = nil,
	MultiplayerServerLobby = nil,
	SceneEditor = nil,
	ACDropShip = {
		AutoStabilize = "Automatically stabilize the craft with the upper thrusters? Defaults to yes.",
		MaxEngineAngle = "Maximum engine rotation in degrees.",
		LateralControlSpeed = "Abstract speed at which Lateralcontroll is changed.",
		HoverHeightModifier = "The modifier for the height at which this ACDropShip should hover above terrain when releasing its cargo. Used in cpp and Lua AI.",
	},
	ACrab = {
		-- JumpTime = "",
		JetTime = "The max total time, in milliseconds, that the jetpack can be used without pause.",
		-- JumpReplenishRate = "",
		JetReplenishRate = "A multiplier affecting how fast the jetpack fuel will replenish when not in use. 1 means that jet time replenishes at 2x speed in relation to depletion.",
		-- JumpAngleRange = "",
		JetAngleRange = "Ratio at which the jetpack angle follows aim angle.",
		AimRangeUpperLimit = "The maximum angle MountedMO can be aimed up, positive values only, in radians.",
		AimRangeLowerLimit = "The maximum angle MountedMO can be aimed down, positive values only, in radians.",
	},
	ACraft = {
		Exit = {
			VelocitySpread = "The spread in velocity, ratio.",
			Radius = "The width from the center tanget created by the velocity vector out from the offet point. This times two gives the total width of the opening.",
			Range = "How far away the exit can suck objects in from.",
		},
		HatchDelay = "The time it takes to open or close the hatch, in milliseconds.",
		DeliveryDelayMultiplier = "Mutliplier to apply to default delivery time.",
		ExitInterval = "The delay between each exiting passenger Actor.",
		CanLand = "Whether this is capable of landing on the ground at all.",
		MaxPassengers = "The maximum number of actors that fit in the inventory.",
		ScuttleIfFlippedTime = "The time after which the craft will scuttle automatically, if tipped over.",
		ScuttleOnDeath = "Whether the craft will self-destruct at zero health.",
	},
	ACRocket = {
		MaxGimbalAngle = "How much the main engine is able to tilt in order to stabilize the rocket.",
	},
	Activity = {
		Description = "User-friendly description of what this Activity is all about.",
		SceneName = "The name of the Scene in which this Activity takes place.",
		MaxPlayerSupport = "How many separate players this Activity can support at the same time.",
		MinTeamsRequired = "How many separate teams this Activity can support at the same time.",
		Difficulty = "Current difficulty setting of this Activity.",
		CraftOrbitAtTheEdge = "If true then on non-wrapping maps craft beyond the edge of the map are considered orbited.",
		InCampaignStage = "Which stage of the campaign this Activity appears in, if any (-1 means it's not in the campaign).",
		TeamOfPlayer1 = "",
		TeamOfPlayer2 = "",
		TeamOfPlayer3 = "",
		TeamOfPlayer4 = "The designated team of player 4.",
		Player1IsHuman = "",
		Player2IsHuman = "",
		Player3IsHuman = "",
		Player4IsHuman = "Whether player 4 is Human or not, and needs a screen etc.",
		Team1Name = "",
		Team2Name = "",
		Team3Name = "",
		Team4Name = "Name of team 4.",
		Team1Funds = "",
		Team2Funds = "",
		Team3Funds = "",
		Team4Funds = "Gold counter for team 4.",
		TeamFundsShareOfPlayer1 = "",
		TeamFundsShareOfPlayer2 = "",
		TeamFundsShareOfPlayer3 = "",
		TeamFundsShareOfPlayer4 = "The ratio of how much player 4 contributed to their team's funds at the start of the Activity.",
		FundsContributionOfPlayer1 = "",
		FundsContributionOfPlayer2 = "",
		FundsContributionOfPlayer3 = "",
		FundsContributionOfPlayer4 = "How much player 4 contributed to their team's funds at the start of the Activity.",
	},
	Actor = {
		Status = "0 for STABLE, 1 for UNSTABLE, 2 for INACTIVE, 3 for DYING, and 4 for DEAD.",
		DeploymentID = "ID of deployment which spawned this actor.",
		PassengerSlots = "How many passenger slots this actor will take in a craft.",
		Health = "Health of the actor.",
		MaxHealth = "Maximum health of the actor.",
		ImpulseDamageThreshold = "Threshold for taking damage from travel impulses, in kg * m/s.",
		StableRecoveryDelay = "The delay before regaining stability after losing it, in milliseconds.",
		AimAngle = "Current Aim angle within the AimRange.",
		AimRange = "The arc range of the aiming angle, in each direction, in radians. Eg if HalfPI, it means full 180 degree range.",
		AimDistance = "How far the actor aims/looks by default.",
		SharpAimDelay = "The time it takes to achieve complete full sharp aiming.",
		SightDistance = "How far this guy's AI can see when he's just looking ahead.",
		Perceptiveness = "How perceptive this is of alarming events going on around him, 0.0 - 1.0.",
		CanRevealUnseen = "Whether this actor can reveal unseen areas by looking.",
		CharHeight = "How tall the Actor is in pixels.",
		MaxInventoryMass = "The mass limit for this Actor's inventory. -1 means there's no limit.",
		AIMode = "The current mode the AI is set to perform as.",
		Organic = "Flag for whether this Actor is organic. Useful for lua purposes and mod support.",
		Mechanical = "Flag for whether this Actor is robotic. Useful for lua purposes and mod support.",
	},
	ADoor = {
		DoorMoveTime = "The time it takes to open or close the door in milliseconds.",
		ClosedByDefault = "Whether the closed position is the default.",
		ResetDefaultDelay = "How long the door stays in the non-default state before returning to the default state.",
		SensorInterval = "The delay between each sensing pass in milliseconds.",
		DrawMaterialLayerWhenOpen = "Whether to draw the door's silhouette to the terrain material layer when fully open.",
		DrawMaterialLayerWhenClosed = "Whether to draw the door's silhouette to the terrain material layer when fully closed.",
	},
	ADSensor = {
		SkipPixels = "How many pixels to skip between sensing pixels.",
	},
	AEmitter = {
		EmissionEnabled = "Whether emitting is currently enabled or not.",
		EmissionCount = "The number of emissions emitted since emission was last enabled.",
		EmissionCountLimit = "The max number of emissions to emit per emit being enabled.",
		ParticlesPerMinute = "Emission rate.",
		NegativeThrottleMultiplier = "The multiplier applied to the emission rate when throttle is negative. Relative to the absolute throttle value.",
		PositiveThrottleMultiplier = "The multiplier applied to the emission rate when throttle is positive. Relative to the absolute throttle value.",
		Throttle = "The normalized throttle which controls the MSPE between 1.0 * m_MSPERange and -1.0 * m_MSPERange. 0 means emit the regular m_PPM amount.",
		EmissionsIgnoreThis = "Whether this' emissions ignore hits with itself, even if they are set to hit other MOs.",
		BurstSize = "The number of particles in the first initial burst of emissions that this AEmitter will generate upon emitting.",
		BurstScale = "The scale factor that will be applied to the regular spread and emission velocity to get the the burst particle parameters.",
		BurstDamage = "Damage dealt to the attached-to parent upon bursting.",
		EmitterDamageMultiplier = "Damage multiplier derived from penetrating particle. Affects both burst and emit damage values.",
		BurstSpacing = "The shortest possible time between bursts, in milliseconds.",
		BurstTriggered = "Indicates that a burst is set to happen during the next Update.",
		EmissionDamage = "The amount of damage points that this emitter collects when emitting one non-burst particle.",
		FlashScale = "Flash display scale.",
		FlashOnlyOnBurst = "Whether to only display flash on bursts, and not on any emission frame.",
		LoudnessOnEmit = "How far this is audiable (in screens) when emitting as a jetpack or craft engine.",
	},
	AHuman = {
		ThrowPrepTime = "The duration it takes this AHuman to fully charge a throw.",
		LookToAimRatio = "Ratio at which the head's rotation follows the aim angle.",
		-- JumpTime = "",
		JetTime = "The max total time, in milliseconds, that the jetpack can be used without pause.",
		-- JumpReplenishRate = "",
		JetReplenishRate = "A multiplier affecting how fast the jetpack fuel will replenish when not in use. 1 means that jet time replenishes at 2x speed in relation to depletion.",
		-- JumpAngleRange = "",
		JetAngleRange = "Ratio at which the jetpack angle follows aim angle.",
		FGArmFlailScalar = "The rate at which this AHuman's FG Arm follows the the bodily rotation. Best to keep this at 0 so it doesn't complicate aiming.",
		BGArmFlailScalar = "The rate at which this AHuman's BG Arm follows the the bodily rotation. Set to a negative value for a 'counterweight' effect.",
		ArmSwingRate = "Controls the rate at which this AHuman's arms follow the movement of its legs.",
		StandRotAngleTarget = "Rotation angle target for the STAND state.",
		WalkRotAngleTarget = "Rotation angle target for the WALK state.",
		CrouchRotAngleTarget = "Rotation angle target for the CROUCH state.",
		JumpRotAngleTarget = "Rotation angle target for the JUMP state.",
	},
	Arm = {
		GripStrength = "The strength with which this Arm will grip its HeldDevice. Effectively supercedes the HeldDevice's JointStrength.",
		ThrowStrength = "The strength with which this Arm will throw a ThrownDevice. Effectively supercedes the ThrownDevice's ThrowVelocity values.",
		MaxLength = "The maximum reaching length of this Arm. Max distance between the joint position and the hand offset. Length of a straight arm sprite in pixels.",
		WillIdle = "Whether this Arm will go to the idle position if it didn't reach.",
		MoveSpeed = "How fast the arm moves to a reach target, on a scale from 0.0 (frozen) to 1.0 (instantly there).",
	},
	AtomGroup = {
		AutoGenerate = "Whether the Atoms in this AtomGroup were automatically generated based on a sprite, or manually defined.",
		Resolution = "The density of Atoms in this AtomGroup along the outline of the owning MOSR's graphical representation. Higher values mean more pixels are skipped along the outline when placing Atoms. For example: a box that is 20x20px will have an outline of 80px, with a resolution value of 10 an Atom will be placed every 10 pixels on this outline, resulting in an AtomGroup that consists of 8 Atoms total with 2 Atoms on each plane. Note that the outline isn't actually 'unwrapped' and higher values may result in slightly less accurate Atom placement on complex sprites. 0 means the Atoms in this AtomGroup were defined manually. 1 means the whole outline will be populated with Atoms, resulting in the most accurate physical representation.",
		Depth = "The depth Atoms in this AtomGroup are placed off the edge of the owning MOSR's graphical representation outline towards it's center, in pixels.",
	},
	Attachable = {
		DrawAfterParent = "Whether to draw this Attachable after (in front of) or before (behind) the parent.",
		DeleteWhenRemovedFromParent = "Whether this Attachable should be deleted when it's removed from its parent.",
		ApplyTransferredForcesAtOffset = "Whether forces transferred from this Attachable should be applied at the rotated parent offset (which will produce torque), or directly at the parent's position. Mostly useful to make jetpacks and similar emitters viable.",
		GibWithParentChance = "The percentage chance that this Attachable will gib when its parent does. 0 means never, 1 means always.",
		ParentGibBlastStrengthMultiplier = "The multiplier for how strongly this Attachable's parent's gib blast strength will be applied to it when its parent's gibs.",
		JointStrength = "The amount of impulse force needed on this to detach it from the host Actor, in kg * m/s. A value of 0 means the join is infinitely strong and will never break naturally.",
		-- Strength = "",
		JointStiffness = "The normalized joint stiffness scalar. 1.0 means impulse forces on this attachable will be transferred to the parent with 100% strength, 0 means they will not transfer at all.",
		-- Stiffness = "",
		InheritsHFlipped = "Whether this Attachable should inherit its parent's HFlipped. Defaults to 1 (normal inheritance).",
		InheritsRotAngle = "Whether this Attachable should inherit its parent's RotAngle. Defaults to true.",
		-- InheritedRotAngleRadOffset = "",
		InheritedRotAngleOffset = "The offset in radians by which this Attachable should be rotated when it's set to inherit its parent's rotation angle. Defaults to 0.",
		InheritedRotAngleDegOffset = "The offset in degrees by which this Attachable should be rotated when it's set to inherit its parent's rotation angle. Defaults to 0.",
		InheritsFrame = "Whether this Attachable should inherit its parent's Frame. Defaults to false.",
		CollidesWithTerrainWhileAttached = "Whether this attachable currently has terrain collisions enabled while it's attached to a parent.",
	},
	BunkerAssembly = {
		ParentScheme = "The name of the parent BunkerAssemblyScheme.",
	},
	BunkerAssemblyScheme = {
		Limit = "How many assemblies can be placed on one scene.",
		OneTypePerScene = "If this is true then sceneman must select a single assembly for this scheme and use it everywhere on the scene.",
		MaxDeployments = "How many deployments should be selected during placement.",
	},
	Deployment = {
		SpawnRadius = "The radius around this deployment that gets checked if another actor/item of the same type and name already exists and will block re-spawning a new one by this.",
		WalkRadius = "The radius around this deployment that gets checked if an actor spawned by this deployment is present. If it is, deployment is blocked.",
		ID = "Unique deployment ID, assigned to units deployed by this deployment.",
		HFlipped = "Whether the deployment and its loadout is flipped.",
	},
	Emission = {
		ParticlesPerMinute = "Emission rate.",
		BurstSize = "The number of particles in the first initial burst of emissions that this AEmitter will generate upon emitting.",
		Spread = "The angle spread of velocity of the emitted MO's to each side of the m_EmitAngle angle, in radians. PI/2 would mean that MO's fly out to one side only, with the m_Rotation defining the middle of that half circle.",
		MinVelocity = "The minimum velocity an emitted MO can have when emitted.",
		MaxVelocity = "The maximum velocity an emitted MO can have when emitted.",
		LifeVariation = "The variation in life time of each emitted aprticle, in percentage of the existing life time of the partilcle.",
		PushesEmitter = "Whether these emissions push the emitter around with recoil or not.",
		InheritsVel = "How much of the parents velocity this emission inherits.",
		StartTimeMS = "When to start this emission, in milliseconds.",
		StopTimeMS = "When to stop this emission, in milliseconds.",
	},
	Gib = {
		Count = "The number of copies of the GibParticle that will be spawned.",
		Spread = "The angle spread of the spawned GibParticle objects to each side of the parent's angle in radians.",
		MinVelocity = "The minimum velocity a GibParticle object can have when spawned.",
		MaxVelocity = "The maximum velocity a GibParticle object can have when spawned.",
		LifeVariation = "The per-Gib variation in Lifetime, in percentage of the existing Lifetime of the gib.",
		InheritsVel = "Whether this Gib should inherit the velocity of the exploding parent or not.",
		IgnoresTeamHits = "Whether this Gib should ignore hits with the team of the exploding parent or not.",
		SpreadMode = "Determines what kind of logic is used when applying velocity to the GibParticle objects.",
	},
	GlobalScript = {
		LuaClassName = "The name of the class (table) defining the logic of this in Lua, as specified in the script file.",
		LateUpdate = "Whether this GlobalScript should be updated late, i.e. after the standard MovableMan update.",
	},
	HDFirearm = {
		RateOfFire = "If 0, firearm is semi-automatic (ie only one discharge per activation).",
		ActivationDelay = "Delay between activation and full round output is achieved, in milliseconds.",
		DeactivationDelay = "Delay between release of activation and another can be started, in milliseconds.",
		ReloadTime = "Reload time in milliseconds.",
		FullAuto = "Whether this HDFirearm is full or semi-auto.",
		FireIgnoresThis = "Whether particles fired from this HDFirearm will ignore hits with itself, and the root parent of this HDFirearm, regardless if they are set to hit MOs.",
		Reloadable = "Whether this HDFirearm is reloadable by normal means.",
		RecoilTransmission = "The normalized joint stiffness scalar. 1.0 means impulse forces on this attachable will be transferred to the parent with 100% strength, 0 means they will not transfer at all.",
		IsAnimatedManually = "If true m_Frame is not changed during an update hence the animation is done by external Lua code.",
		ShakeRange = "Range of normal shaking of entire weapon.",
		SharpShakeRange = "Range of shaking of entire weapon during sharp aiming.",
		NoSupportFactor = "Factor for how much more weapon shakes if it isn't supported by a second hand.",
		ParticleSpreadRange = "Range of spread angle of fired particles, in one direction.",
		ShellEjectAngle = "Angle in which shells are ejected relative to this weapon.",
		ShellSpreadRange = "Range of spread angle of ejected shells, in one direction.",
		ShellAngVelRange = "Range of spread in ang vel of ejected shells, in one direction.",
		ShellVelVariation = "The velocity variation scalar of ejected shells.",
		LegacyCompatibilityRoundsAlwaysFireUnflipped = "Legacy compatibility flag to make it so rounds don't flip with the gun. Useful for old mods with things like missiles that accounted for the old code that didn't flip them properly.",
	},
	HeldDevice = {
		HeldDeviceType = "Indicates what kind of held device this is, see the HeldDeviceType enum.",
		OneHanded = "Can be wielded well with one hand or not.",
		DualWieldable = "Can be wielded with bg hand or not.",
		GripStrengthMultiplier = "The multiplier for how well this HeldDevice can be gripped by Arms.",
		SharpLength = "How much farther the player can see when aiming this sharply.",
		Loudness = "How loud this device is when activated. 0 means perfectly quiet 0.5 means half of normal (normal equals audiable from ~half a screen).",
	},
	Icon = {
		FrameCount = "Number of frames in this Icon's animation.",
	},
	Leg = {
		WillIdle = "Whether the Leg will go to idle position if the target position is above the Leg's joint position.",
		MoveSpeed = "How fast the Leg moves to a reach target, 0 means it doesn't and 1 means it moves instantly.",
	},
	LimbPath = {
		StartSegCount = "The number of starting segments, counting into the path from its beginning, that upon restart of this path will be tried in reverse order till one which yields a starting position that is clear of terrain is found.",
		EndSegCount = "The segment after which foot collisions will be disabled for this limbpath, if it's for legs.",
		SlowTravelSpeed = "The constant speed that the limb traveling this path slowly has in m/s.",
		NormalTravelSpeed = "The constant speed that the limb traveling this path normally has in m/s.",
		FastTravelSpeed = "The constant speed that the limb traveling this path quickly has in m/s.",
		PushForce = "The max force that a limb travelling along this path can push, in kg * m/(s^2).",
	},
	Loadout = nil,
	Magazine = {
		RoundCount = "How many rounds in mag. Negative value means infinite ammo.",
		RTTRatio = "The ratio between regular and tracer rounds. 0 means no tracers. e.g. 3 means every third round will be a tracer. ie Round To Tracer (RTT) ratio.",
		Discardable = "Whether this magazine should be released into the scene when discarded, or just be deleted instead.",
		AIBlastRadius = "Tells the AI what distance in pixels from this round is mostly safe.",
	},
	Material = {
		Index = "Index of this in the material palette. 0 - 255.",
		Priority = "The priority that a pixel of this material has to be displayed. The higher the number, the higher chances that a pixel of this material will be drawn on top of others.",
		Piling = "The amount of times a dislodged pixel of this Material will attempt to relocate upwards, when intersecting a terrain pixel of the same Material.",
		-- Integrity = "",
		StructuralIntegrity = "The impulse force that a particle needs to knock loose a terrain pixel of this material. In kg * m/s.",
		-- Restitution = "",
		Bounce = "A scalar value that defines the restitution (elasticity). 1.0 = no kinetic energy is lost in a collision, 0.0 = all energy is lost (plastic).",
		Friction = "A scalar value that defines the friction coefficient. 1.0 = will snag onto everything, 0.0 = will glide with no friction.",
		Stickiness = "A scalar value that defines the stickiness coefficient (no sticky 0.0 - 1.0 max). Determines the likelihood of something of this material sticking when a collision occurs.",
		DensityKGPerVolumeL = "Density in Kg/L.",
		DensityKGPerPixel = "Density in kg/pixel, usually calculated from the KG per Volume L property.",
		GibImpulseLimitPerVolumeL = "How much impulse gib limit of an object increases per liter of this material.",
		GibWoundLimitPerVolumeL = "How much wound gib limit of an object increases per liter of this material.",
		SettleMaterial = "The material to turn particles of this into when they settle on the terrain. 0 here means to spawn this material.",
		-- SpawnMaterial = "",
		TransformsInto = "The material to spawn instead of this one for special effects, etc. 0 here means to spawn this material.",
		IsScrap = "Whether this material is scrap material made from gibs of things that have already been blown apart.",
		UseOwnColor = "Whether to use the own color when a pixel of this material is knocked loose from the terrain. If 0, then the terrain pixel's color will be applied instead.",
	},
	MetaPlayer = {
		Name = "The name of the player.",
		Team = "The team index of this player.",
		Human = "Whether the player is human controlled.",
		InGamePlayer = "The in-game player controls that this MetaPlayer is mapped to.",
		Aggressiveness = "Normalized aggressiveness temperament of this if it's an AI player. 0 is min, 1.0 max.",
		GameOverRound = "Which round this player ended up getting to. If negative, he's still in the game.",
		NativeTechModule = "The tech module that will have native pricing for this player.",
		NativeCostMultiplier = "The cost multiplier of native groups available to this player.",
		ForeignCostMultiplier = "The cost multiplier of foreign groups available to this player.",
		BrainPool = "The current number of unused brains left available to this player in the pool.",
		Funds = "The current funds of this player, in oz.",
		OffensiveBudget = "The money allocated by this player this round to attack or explore a specific site.",
		OffensiveTarget = "Name of the Scene this player is targeting for its offensive this round.",
	},
	MetaSave = {
		SavePath = "The full path to the ini file which stores the stat of MetaMan this is associated with.",
		PlayerCount = "The number of players in this saved game.",
		Difficulty = "Game difficulty.",
		RoundCount = "The round this game is on.",
		SiteCount = "The site count of this game.",
	},
	MOPixel = {
		MinLethalRange = "Lower bound multiplier for setting LethalRange at random. By default, 1.0 equals one screen.",
		MaxLethalRange = "Upper bound multiplier for setting LethalRange at random. By default, 1.0 equals one screen.",
	},
	MOSParticle = nil,
	MOSprite = {
		FrameCount = "Number of frames, or elements in the m_aSprite array.",
		SpriteAnimMode = "Which animation to use for the body.",
		SpriteAnimDuration = "Body animation duration, how long in milliseconds that each full body animation cycle takes.",
		HFlipped = "Whether flipped horizontally or not.",
		AngularVel = "The angular velocity by which this MovableObject rotates, in radians per second (r/s).",
		SettleMaterialDisabled = "Whether to disable the settle material ID when this gets drawn as material.",
	},
	MOSRotating = {
		DeepCheck = "Whether to check for deep penetrations.",
		OrientToVel = "How much to orient the rotation of this to match the velocity vector each frame 0 = none, 1.0 = immediately align with vel vector.",
		GibImpulseLimit = "The amount of impulse force required to gib this, in kg * (m/s). 0 means no limit.",
		GibWoundLimit = "The number of wounds that will gib this MOSRotating. 0 means that it can't be gibbed via wounds.",
		-- WoundLimit = "",
		GibBlastStrength = "The strength with which Gibs and Attachables will get launched when this MOSRotating is gibbed.",
		WoundCountAffectsImpulseLimitRatio = "The rate at which this MOSRotating's wound count will diminish the impulse limit.",
		GibAtEndOfLifetime = "Whether this MOSRotating should gib when it reaches the end of its lifetime, instead of just deleting.",
		EffectOnGib = "Whether to flash effect on gib.",
		LoudnessOnGib = "How far this is audible (in screens) when gibbing.",
		DamageMultiplier = "Damage multiplier for this MOSRotating.",
	},
	MovableObject = {
		Mass = "In metric kilograms (kg).",
		Scale = "The scale that this MovableObject's representation will be drawn in, 1.0 being 1:1.",
		GlobalAccScalar = "How this is affected by global effects, from +1.0 to -1.0. Something with a negative value will 'float' upward.",
		AirResistance = "How much this is affected by air resistance when traveling over a second, 0 to 1.0, with 0 as default.",
		AirThreshold = "At which threshold of velocity, in m/s, the effect of AirResistance kicks in.",
		PinStrength = "The impulse force in kg * (m/s) needed to unpin this. Pinned MO's don't travel at all.",
		RestThreshold = "The threshold in milliseconds as to how long this MO should wait after being at rest to get flagged to be copied to the terrain.",
		LifeTime = "How many milliseconds this MovableObject will exist.",
		Sharpness = "The sharpness factor that gets added to single pixel hit impulses in applicable situations.",
		HitsMOs = "Whether this MovableObject will test for collisions against other MOs.",
		GetsHitByMOs = "Whether this MovableObject can get hit by other MOs.",
		IgnoresTeamHits = "Whether this ignores collisions with other MOs of the same Team as this.",
		IgnoresAtomGroupHits = "This currently ignores hits with other AtomGroup MOs.",
		IgnoresAGHitsWhenSlowerThan = "This will flip the IgnoreAtomGroupHits on or off depending on whether this MO is travelling slower than the threshold here, in m/s. This is disabled if set to negative value, and 0 means AG hits are never ignored.",
		RemoveOrphanTerrainRadius = "The radius that should be looked to remove orphaned terrain on terrain penetration. Must not be greater than SceneMan::ORPHANSIZE, or will be truncated.",
		RemoveOrphanTerrainMaxArea = "What is the max orphan area to trigger terrain removal.",
		RemoveOrphanTerrainRate = "Rate at which terrain removal checks will be triggered.",
		MissionCritical = "This is mission critical, which means it should NEVER be settled or destroyed by gibbing.",
		CanBeSquished = "Whether this can be destroyed by being squished into the terrain.",
		HUDVisible = "Whether to draw the HUD.",
		ScriptPath = "The path to a Lua script file to run.",
		EffectStartTime = "Effect's showing is delayed by this amount into this' lifetime, in milliseconds.",
		EffectRotAngle = "The effect's rotation angle.",
		InheritEffectRotAngle = "Whether effect's rot angle should be inherited from parent.",
		RandomizeEffectRotAngle = "Whether effect's rot angle should be randomized on creation.",
		RandomizeEffectRotAngleEveryFrame = "Whether effects rot angle should be randomized every frame.",
		EffectStopTime = "Effect's ending this far into the lifetime of this, in milliseconds. 0 means as long as this is alive.",
		EffectStartStrength = "The intensity of the effect blend at the start time, 0-255.",
		EffectStopStrength = "The intensity of the effect blend at the stop time, 0-255.",
		EffectAlwaysShows = "The effect can't be obscured.",
		DamageOnCollision = "Whether this should cause health-damage on collision.",
		DamageOnPenetration = "Whether this should cause health-damage on penetration.",
		WoundDamageMultiplier = "Damage multiplier transferred to wound inflicted by this object on penetration.",
		ApplyWoundDamageOnCollision = "Whether this should apply wound damage on collision, respecting WoundDamageMultiplier and without creating a wound.",
		ApplyWoundBurstDamageOnCollision = "Whether this should apply wound burst damage on collision, respecting WoundDamageMultiplier and without creating a wound.",
		IgnoreTerrain = "Whether this MO should ignore terrain when traveling.",
		SimUpdatesBetweenScriptedUpdates = "The number of Sim updates between each scripted update for this MovableObject.",
	},
	PEmitter = {
		EmissionEnabled = "Whether emitting is currently enabled or not.",
		EmissionCount = "The number of emissions emitted since emission was last enabled.",
		EmissionCountLimit = "The max number of emissions to emit per emit being enabled.",
		ParticlesPerMinute = "Emission rate in Particles Per Minute.",
		NegativeThrottleMultiplier = "The multiplier applied to the emission rate when throttle is negative. Relative to the absolute throttle value.",
		PositiveThrottleMultiplier = "The multiplier applied to the emission rate when throttle is positive. Relative to the absolute throttle value.",
		Throttle = "The normalized throttle which controls the MSPE between 1.0 * m_MSPERange and -1.0 * m_MSPERange. 0 means emit the regular m_PPM amount.",
		EmissionsIgnoreThis = "Whether this' emissions ignore hits with itself, even if they are set to hit other MOs.",
		BurstSize = "The number of particles in the first initial burst of emissions that this will generate upon emitting, where 0 means none.",
		BurstScale = "The scale factor that will be applied to the regular spread and emission velocity to get the the burst particle parameters.",
		BurstSpacing = "The shortest possible time between bursts, in milliseconds.",
		BurstTriggered = "Indicates that a burst is set to happen during the next Update.",
		FlashScale = "The visual scale factor of the flash effect.",
		FlashOnlyOnBurst = "Whether to only display flash on bursts, and not on any emission frame.",
		LoudnessOnEmit = "How far this is audiable (in screens) when emitting as a jetpack or craft engine.",
	},
	PieMenu = {
		IconSeparatorMode = "The icon separator mode of this PieMenu.",
		FullInnerRadius = "The full inner radius of the PieMenu's background, in pixels.",
		BackgroundThickness = "The thickness of the PieMenu's background, in pixels.",
		BackgroundSeparatorSize = "The size of the PieMenu's background separators, in pixels. Used differently based on the menu's IconSeparatorMode.",
		DrawBackgroundTransparent = "Whether the PieMenu's background should be drawn transparently.",
		BackgroundColor = "The color used for drawing the PieMenu's background.",
		BackgroundBorderColor = "The color used for drawing borders for the PieMenu's background.",
		SelectedItemBackgroundColor = "The color used for drawing selected PieMenu items' backgrounds.",
	},
	PieSlice = {
		Type = "The slice type, also used to determine the icon.",
		Direction = "The desired direction/location of this on the PieMenu.",
		CanBeMiddleSlice = "Whether this PieSlice is allowed to be the middle slice. Defaults to true and should usually stay that way.",
		Enabled = "Whether this PieSlice is enabled or disabled and grayed out.",
		ScriptPath = "The path to a Lua script file to run.",
		FunctionName = "Name of the function in the script this PieSlice runs. Used for safely reloading scripts.",
		DrawFlippedToMatchAbsoluteAngle = "Whether this PieSlice should draw flipped based on its absolute angle (i.e. its angle accounting for its pie menu's rotation).",
	},
	Round = {
		ParticleCount = "How many particle copies there are in this Round.",
		FireVelocity = "The velocity with which this Round is fired.",
		InheritsFirerVelocity = "Whether this Round should inherit velocity from its firer.",
		Separation = "The range of separation between particles in this Round, in pixels.",
		LifeVariation = "The random variation in life time of each fired particle, in percentage of their life time.",
		ShellVelocity = "The maximum velocity with which this Round's shell/casing is launched.",
		AILifeTime = "For overriding LifeTime when executing the AI shooting scripts.",
		AIFireVel = "For overriding FireVel when executing the AI shooting scripts.",
		AIPenetration = "For overriding the bullets ability to penetrate material when executing the AI shooting scripts.",
	},
	Scene = {
		Area = {
			Name = "The name of this Area.",
		},
		MetagamePlayable = "Whether at all eligible for the Metagame.",
		Revealed = "Whether this is revealed on the metagame planet map yet or not.",
		MetasceneParent = "Name of a scene which can be replaced by this scene in MetaGame Scenes with m_MetaSceneParent field set will be invisible for editors and activities unless ShowMetaScenes flag in settings.ini is set.",
		MetagameInternal = "Whether this scene must be shown anywhere in UIs.",
		ScriptSave = "Whether this scene must be shown anywhere in UIs.",
		OwnedByTeam = "Owned by which Team, if any (<0 if none).",
		RoundIncome = "Total income this place generates per Metagame round for its owner team.",
		P1BuildBudget = "",
		P2BuildBudget = "",
		P3BuildBudget = "",
		P4BuildBudget = "Budget in oz this place is allocated to player 4 for a metagame round for building (applying) blueprint objects.",
		P1BuildBudgetRatio = "",
		P2BuildBudgetRatio = "",
		P3BuildBudgetRatio = "",
		P4BuildBudgetRatio = "Budget in ratio of player 4 for a metagame round. This is used to reset the BuildBudget to match the ratio that player 4 budgeted to this site in the previous turn.",
		AutoDesigned = "Whether this should be automatically designed by the AI Plan even if it's owned by a human player.",
		TotalInvestment = "The total amount of gold (in oz) that has been invested in the defenses of this site, by all teams.",
		ScanScheduledTeam1 = "",
		ScanScheduledTeam2 = "",
		ScanScheduledTeam3 = "",
		ScanScheduledTeam4 = "Whether this Scene is scheduled to be orbitally scanned by team 4.",
	},
	SceneLayer = {
		WrapX = "Whether wrapping is enabled on the X axis.",
		WrapY = "Whether wrapping is enable on the Y axis.",
	},
	SceneObject = {
		SOPlacer = {
			HFlipped = "Whether horizontal flipping is part of the placement.",
			Team = "The team of the placed object.",
		},
		GoldValue = "How much this SceneObject costs to purchase, in oz's of gold.",
		-- GoldCost = "",
		Buyable = "Whether this shows up in the buy menu at all.",
		BuyableMode = "In which buy lists this SceneObject is available when buyable.",
		Team = "The team this object belongs to. -1 if none.",
		PlacedByPlayer = "The player this was placed by in edit mode.",
	},
	SLBackground = {
		FrameCount = "The total number of frames in this SLBackground's animation.",
		SpriteAnimMode = "The mode in which this SLBackground is animating. See SpriteAnimMode enumeration.",
		SpriteAnimDuration = "The duration it takes to complete a full animation cycle, in milliseconds.",
		IsAnimatedManually = "Whether this SLBackground's animation is handled manually/externally and should not be handled during Update().",
		DrawTransparent = "Whether pixels marked as transparent (index 0, magenta) are skipped when drawing or not (masked drawing).",
		IgnoreAutoScaling = "Whether auto-scaling settings are ignored and the read-in scale factor is used instead.",
		CanAutoScrollX = "Whether auto-scrolling is enabled on the X axis, but not whether auto-scrolling actually happens on this axis.",
		CanAutoScrollY = "Whether auto-scrolling is enabled on the Y axis, but not whether auto-scrolling actually happens on this axis.",
		AutoScrollStepInterval = "The duration between auto-scroll steps, in milliseconds.",
	},
	SLTerrain = nil,
	SoundContainer = {
		SoundSelectionCycleMode = "How the SoundSet should choose the next sound or SoundSet to play when SelectNextSound is called.",
		-- CycleMode = "",
		SoundOverlapMode = "How the SoundContainer should behave when it tries to play again while already playing.",
		Immobile = "Whether this SoundContainer's sounds should be treated as immobile, i.e. not affected by 3D sound effects. Mostly used for GUI sounds and the like.",
		AttenuationStartDistance = "The distance away from the AudioSystem listener to start attenuating this sound. Attenuation follows FMOD 3D Inverse roll-off model.",
		LoopSetting = "Number of loops (repeats) the SoundContainer's sounds should play when played. 0 means it plays once, -1 means it plays until stopped.",
		Priority = "The mixing priority of this SoundContainer's sounds. Higher values are more likely to be heard.",
		AffectedByGlobalPitch = "Whether this SoundContainer's sounds should be able to be altered by global pitch changes.",
		Volume = "The current natural volume of this SoundContainer's sounds.",
		Pitch = "The current natural pitch of this SoundContainer's sounds.",
		PitchVariation = "The randomized pitch variation of this SoundContainer's sounds. 1 means the sound will vary a full octave both ways.",
	},
	SoundSet = {
		SoundSelectionCycleMode = "How the SoundSet should choose the next sound or SoundSet to play when SelectNextSound is called.",
	},
	TDExplosive = {
		IsAnimatedManually = "If true m_Frame is not changed during an update hence the animation is done by external Lua code.",
	},
	TerrainDebris = {
		DebrisPieceCount = "How many individual pieces this debris has.",
		DebrisPlacementMode = "This will determine how target Material checking and debris applying should behave. If set to NoPlacementRestrictions, checking will continue to penetrate down into non-air Materials to try to find the target Material.",
		OnlyBuried = "Whether to place a piece of this only if a spot where it fits completely buried in the terrain is found.",
		MinDepth = "Minimum depth debris pieces can be placed into the terrain contour, in pixels. This can be negative for debris placed above ground.",
		MaxDepth = "Maximum depth debris pieces can be placed into the terrain contour, in pixels. This can be negative for debris placed above ground.",
		MinRotation = "Minimum rotation debris pieces can be rotated, in degrees. Positive values are clockwise.",
		MaxRotation = "Maximum rotation debris pieces can be rotated, in degrees. Positive values are clockwise.",
		CanHFlip = "Whether debris pieces can be flipped horizontally.",
		CanVFlip = "Whether debris pieces can be flipped vertically.",
		FlipChance = "The chance a debris piece will be flipped on either axis.",
		DensityPerMeter = "Approximate density of debris pieces per meter.",
	},
	TerrainFrosting = {
		MinThickness = "The minimum height above the target Material, in pixels.",
		MaxThickness = "The maximum height above the target Material, in pixels.",
		InAirOnly = "Whether the frosting only appears where there is air (i.e. does not appear where the terrain background layer is showing).",
	},
	TerrainObject = nil,
	ThrownDevice = {
		MinThrowVel = "The minimum throw velocity this gets when thrown.",
		MaxThrowVel = "The maximum throw velocity this gets when thrown.",
		TriggerDelay = "Time in milliseconds from the time of being thrown to triggering whatever it is that this ThrownDevice does.",
		ActivatesWhenReleased = "Whether this activates when its throw is started, or waits until it is released from the arm that is throwing it.",
	},
	Turret = {
		MountedDeviceRotationOffset = "The relative offset angle (in radians) of the mounted HeldDevice from this Turret's rotation.",
	},
	MetaMan = {
		GameState = "Current Metagame state.",
		GameName = "The save name of the currently played metagame.",
		TeamCount = "The number of Teams in play this game.",
		CurrentRound = "The current round the game is on, starting with count on 0.",
		RevealedScenes = "How many of the scenes have been revealed so far - the whole number. It's a float to increase it slower than once a round.",
		RevealRate = "How many scenes to reveal each round.. can be a fractional that adds up over several days.",
		RevealExtra = "Any extra reveals to make next reveal phase.",
		CurrentOffensive = "The current offensive action that we're about to play next.",
		Difficulty = "Game difficulty.",
	},
	MovableMan = {
		SplashRatio = "The ratio of terrain pixels to be converted into MOPixels upon deep impact of MO.",
	},
	SceneMan = nil,
	SettingsMan = {
		ResolutionX = "Game window width.",
		ResolutionY = "Game window height.",
		ResolutionMultiplier = "The number of times the game window and image should be multiplied and stretched across for better visibility.",
		TwoPlayerSplitscreenVertSplit = "Whether the screen is set to be split vertically when in two player splitscreen, or is default split horizontally.",
		MasterVolume = "Sets all the audio to a specific volume. Does not affect the individual volumes of music or sounds.",
		MuteMaster = "Whether all the audio is muted.",
		MusicVolume = "Global music volume.",
		MuteMusic = "Whether the music channel is muted.",
		SoundVolume = "Global sounds effects volume.",
		MuteSounds = "Whether all the sound effects channels are muted.",
		SoundPanningEffectStrength = "The strength of the sound panning effect, 0 (no panning) - 1 (full panning).",
		ListenerZOffset = "Pulls the audio library's listener back from the scene a bit, so sound isn't fully 3D. 0 offset means sounds are entirely on the left or right.",
		MinimumDistanceForPanning = "Any sound within this distance will have no 3D effect, so they'll always play in both ears fully, instead of all to the left or right.",
		ShowForeignItems = "Do not show foreign items in buy menu.",
		FlashOnBrainDamage = "Whether red flashes on brain damage are on or off.",
		BlipOnRevealUnseen = "Blip if unseen is revealed.",
		MaxUnheldItems = "The maximum number of dropped items.",
		UnheldItemsHUDDisplayRange = "The range in which devices on Scene will show the pick-up HUD.",
		AlwaysDisplayUnheldItemsInStrategicMode = "Whether devices on Scene should always show their pick-up HUD when when the player is in strategic mode.",
		SubPieMenuHoverOpenDelay = "The number of milliseconds a PieSlice with a sub-PieMenu needs to be hovered over for the sub-PieMenu to open.",
		EndlessMode = "Whether endless MetaGame mode is enabled.",
		EnableCrabBombs = "Whether all actors (except Brains and Doors) should be annihilated if a number exceeding the crab bomb threshold is released at once.",
		CrabBombThreshold = "The number of crabs needed to be released at once to trigger the crab bomb effect.",
		ShowEnemyHUD = "Whether the HUD of enemy actors should be visible to the player.",
		SmartBuyMenuNavigation = "Whether swapping to equipment mode and back should change active tabs in the BuyMenu.",
		ScrapCompactingHeight = "The maximum height of a column of scrap terrain to collapse, when the bottom pixel is knocked loose.",
		AutomaticGoldDeposit = "Whether gold gathered by Actors is automatically added into team funds. False means that gold needs to be manually transported into orbit via Craft.",
		ScreenShakeStrength = "A global multiplier applied to screen shaking strength.",
		ScreenShakeDecay = "How quickly screen shake falls off.",
		MaxScreenShakeTime = "The maximum amount of screen shake time, i.e. the number of seconds screen shake will happen until ScreenShakeDecay reduces it to zero.",
		DefaultShakePerUnitOfGibEnergy = "How much the screen should shake per unit of energy from gibbing (i.e explosions), when screen shake amount is auto-calculated.",
		DefaultShakePerUnitOfRecoilEnergy = "How much the screen should shake per unit of energy for recoil, when screen shake amount is auto-calculated.",
		DefaultShakeFromRecoilMaximum = "The maximum amount of screen shake recoil can cause, when screen shake is auto-calculated. This is ignored by per-firearm shake settings.",
		LaunchIntoActivity = "Whether to skip the intro and main menu and launch directly into the set default Activity instead.",
		DefaultActivityType = "The type name of the default Activity to be loaded if nothing else is available.",
		DefaultActivityName = "The preset name of the default Activity to be loaded if nothing else is available.",
		DefaultSceneName = "Default Scene name to load if nothing else is specified.",
		DisableLuaJIT = "Whether to disable LuaJIT or not. Disabling will skip loading the JIT library entirely as just setting 'jit.off()' seems to have no visible effect.",
		RecommendedMOIDCount = "Recommended max MOID's before removing actors from scenes.",
		SimplifiedCollisionDetection = "Whether simplified collision detection (reduced MOID layer sampling) is enabled.",
		SceneBackgroundAutoScaleMode = "Scene background layer auto-scaling mode. 0 for off, 1 for fit screen dimensions and 2 for always upscaled to x2.",
		DisableFactionBuyMenuThemes = "Whether faction BuyMenu theme support is disabled.",
		DisableFactionBuyMenuThemeCursors = "Whether custom cursor support in faction BuyMenu themes is disabled.",
		PathFinderGridNodeSize = "The grid size used by the PathFinder, in pixels.",
		AIUpdateInterval = "How often actor's AI should be updated, i.e. every n simulation updates.",
		EnableParticleSettling = "Whether settling of particles is enabled or not.",
		EnableMOSubtraction = "Whether MOs can get subtracted form the terrain at all.",
		DeltaTime = "The number of seconds that a simulation update delta time should take.",
		RealToSimCap = "The cap of the amount of seconds which can be transferred from the real time to the simulated time in one update.",
		AllowSavingToBase = "Whether editors will allow to select Base.rte as a module to save in.",
		ShowMetaScenes = "Show MetaScenes in editors and activities.",
		SkipIntro = "Whether to play the intro of the game or skip directly to the main menu.",
		ShowToolTips = "Whether tooltips are enabled or not.",
		CaseSensitiveFilePaths = "Sets whether case sensitivity should be enforced when checking for file existence.",
		DisableLoadingScreenProgressReport = "Whether to display the reader progress report during module loading or not. Greatly increases loading speeds when disabled.",
		LoadingScreenProgressReportPrecision = "How accurately the reader progress report tells what line it's reading during module loading. Lower values equal more precision at the cost of loading speed.",
		ConsoleScreenRatio = "The ratio of the screen that the console should cover when opened.",
		ConsoleUseMonospaceFont = "Whether the console text is using the monospace font.",
		AdvancedPerformanceStats = "Whether to show performance graphs on screen or not.",
		MenuTransitionDurationMultiplier = "The multiplier value for the transition durations between different menus.",
		DrawAtomGroupVisualizations = "Whether to draw MOSRotating AtomGroups to the Scene MO color Bitmap.",
		DrawHandAndFootGroupVisualizations = "Whether to draw Actor HandGroups and FootGroups to the Scene MO color Bitmap.",
		DrawLimbPathVisualizations = "Whether to draw Actor LimbPaths to the Scene MO color Bitmap.",
		DrawRaycastVisualizations = "Whether to visibly draw RayCasts to the Scene debug Bitmap.",
		DrawPixelCheckVisualizations = "Whether to visibly draw pixel checks (GetTerrMatter and GetMOIDPixel) to the Scene debug Bitmap.",
		PrintDebugInfo = "Print some debug info in console.",
		MeasureModuleLoadTime = "Whether to measure the duration of data module loading (extraction included). For benchmarking purposes.",
		PlayerNetworkName = "Player name used in network multiplayer matches.",
		NetworkServerName = "LAN server address to connect to.",
		UseNATService = "Whether a NAT service is used for punch-through.",
		NATServiceAddress = "NAT punch-through server address.",
		NATServerName = "Server name to use when connecting via NAT punch-through service.",
		NATServerPassword = "Server password to use when connecting via NAT punch-through service.",
		UseExperimentalMultiplayerSpeedBoosts = "Turns on/off code changes from topkek that may speed up multiplayer.",
		ClientInputFps = "The rate in FPS the client input is sent to the server.",
		ServerTransmitAsBoxes = "Transmit frames as blocks instead of lines. Provides better compression at the cost of higher CPU usage. Though the compression is quite high, it is recommended that the ServerBoxWidth * ServerBoxHeight are less than the MTU size (about 1500 bytes), or packets may be fragmented or even completely dropped by network hardware.",
		ServerBoxWidth = "Width of the transmitted CPU block. Different values may improve bandwidth usage.",
		ServerBoxHeight = "Height of the transmitted CPU block. Different values may improve bandwidth usage.",
		ServerUseHighCompression = "Whether to use higher compression methods (default).",
		ServerUseFastCompression = "Whether to use faster compression methods and conserve CPU.",
		ServerHighCompressionLevel = "Compression level. 10 is optimal, 12 is highest.",
		ServerFastAccelerationFactor = "Acceleration factor, higher values consume more bandwidth but less CPU. The larger the acceleration value, the faster the algorithm, but also lesser the compression. It's a trade-off. It can be fine tuned, with each successive value providing roughly +3% speed. An acceleration value of 1 is the same as regular LZ4_compress_default(). Values <= 0 will be replaced by ACCELERATION_DEFAULT(currently == 1, see lz4 documentation).",
		ServerUseInterlacing = "Use interlacing to heavily reduce bandwidth usage at the cost of visual degradation (unusable at 30 FPS, but may be suitable at 60 FPS).",
		ServerEncodingFps = "Frame transmission rate. Higher value equals more CPU and bandwidth consumption.",
		ServerSleepWhenIdle = "If true puts thread to sleep if it didn't receive anything for 10 seconds to avoid melting the CPU at 100% even if there are no connections.",
		ServerSimSleepWhenIdle = "If true the server will try to put the thread to sleep to reduce CPU load if the sim frame took less time to complete than it should at 30 FPS.",
		VisibleAssemblyGroup = "An assembly group to always show in editors.",
		DisableMod = "The name of a mod to disable.",
		EnableGlobalScript = "The name of a global script to be enabled.",
		MouseSensitivity = "The mouse sensitivity multiplier while in an Activity. This has no effect in menus.",
	},
	MetagameGUI = nil,
	Atom = {
		TrailLength = "The longest the trail should/can get drawn. If 0, no trail is drawn.",
		TrailLengthVariation = "What percentage the trail length of this Atom can vary each frame it's drawn. 0 means no variance, 1 means 100% variance between 0 and its TrailLength.",
	},
	Box = {
		Width = "Width of this box.",
		Height = "Height of this box.",
	},
	Color = {
		Index = "The index of a color from the game's palette.",
		R = "The red value of this Color.",
		G = "The green value of this Color.",
		B = "The blue value of this Color.",
	},
	ContentFile = {
		FilePath = "The file path to a content file, like a .png or a .flac.",
		-- Path = "",
	},
	DataModule = {
		ModuleName = "The friendly name of the data module, like 'My Weapons Mod', as opposed to 'MyMod.rte'.",
		Author = "The name of the author of this module.",
		Description = "A brief description of what this module is and contains.",
		IsFaction = "Whether this data module is considered a faction.",
		IsMerchant = "Whether this data module is considered a merchant. A module defined as a merchant will stop being playable (in Conquest, etc.), but will have its buyable content available for purchase/placement when playing as any other faction (like how base content is). Only has a noticeable effect when the 'Allow purchases from other factions' gameplay setting is disabled. Note that this property takes priority over the 'IsFaction' property. A module that is set as both 'IsFaction = 1' and 'IsMerchant = 1' will be treated as 'IsFaction = 0'.",
		SupportedGameVersion = "The game version this DataModule supports. Needs to match exactly for this DataModule to be allowed. Base DataModules don't need this.",
		Version = "The integer version number of this mod, defaulting to 1.",
		ScanFolderContents = "Indicates whether module loader should scan for any .ini's inside module folder instead of loading files defined in IncludeFile only.",
		IgnoreMissingItems = "Indicates whether module loader should ignore missing items in this module.",
		CrabToHumanSpawnRatio = "Crab-to-human Spawn ratio to replace value from Constants.lua.",
		ScriptPath = "The path to a Lua script file to run when this module is loaded.",
		Require = "The name of a mod that this mod requires to be present.",
	},
	Entity = {
		CopyOf = "A preset to copy.",
		PresetName = "The name of this preset.",
		-- InstanceName = "",
		Description = "The description that will show up in menus.",
		RandomWeight = "The weight of this item when an item gets randomly picked. From 0 to 100. 0 means this item won't ever be picked.",
		AddToGroup = "The group to add this to.",
	},
	GenericSavedData = {
		StringValues = "Strings to store.",
		NumberValues = "Numbers to store.",
	},
	InputMapping = {
		KeyMap = "The keyboard key mapping.",
		MouseButtonMap = "The mouse button mapping.",
		JoyButtonMap = "The joystick button mapping.",
		AxisMap = "The joystick axis mapping.",
		DirectionMap = "The joystick direction mapping.",
	},
	InputScheme = {
		Device = "The InputDevice of this scheme.",
		Preset = "The InputPreset of this scheme.",
		JoystickDeadzoneType = "Which deadzone type is used.",
		JoystickDeadzone = "How much of the input to treat as a deadzone input, i.e. one not registered by the game.",
		DigitalAimSpeed = "A multiplier for the digital aim speed, where 1 represents the default legacy value.",
	},
	Matrix = {
		AngleDegrees = "The angle that this rotational Matrix should represent in degrees.",
		AngleRadians = "The angle that this rotational Matrix should represent in radians.",
	},
	Serializable = nil,
	Vector = {
		X = "The X value of this vector.",
		Y = "The Y value of this vector.",
	},
}
